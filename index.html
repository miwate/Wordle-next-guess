<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Wordle Next Guess</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;800&display=swap" rel="stylesheet">
    <style>
        /* ---- Minimal modern reset & layout fixes ---- */
        *,
        *::before,
        *::after {
            box-sizing: border-box;
        }

        html,
        body {
            height: 100%;
        }

        :where(h1, h2, h3, h4, h5, p, ul, ol) {
            margin: 0;
            padding: 0;
        }

        body {
            margin: 0;
            line-height: 1.5;
            font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
        }

        img,
        svg,
        video,
        canvas {
            display: block;
            max-width: 100%;
        }

        .wrap>* {
            min-width: 0;
        }

        .theme-toggle {
            border: none;
            background: var(--card);
            color: var(--text);
            padding: 6px 10px;
            font-size: 16px;
            border-radius: 10px;
            box-shadow: 0 2px 6px var(--stroke);
            cursor: pointer;
            transition: transform .12s ease, opacity .12s ease;
        }

        .theme-toggle:active {
            transform: scale(.98);
        }

        body {
            background:
                linear-gradient(180deg, var(--bg) 100%);
            color: var(--text);
            padding: 28px;
            box-sizing: border-box;
        }

        /* ---- Layout ---- */
        .wrap {
            max-width: 1120px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 380px 1fr;
            gap: 22px;
        }

        header {
            grid-column: 1/-1;
            display: flex;
            align-items: center;
            gap: 16px
        }

        .logo {
            width: 56px;
            height: 56px;
            border-radius: 12px;
            background: linear-gradient(135deg, var(--accent1), var(--accent2));
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-weight: 800;
            font-size: 20px;
            box-shadow: 0 8px 24px rgba(192, 88, 160, 0.12)
        }

        h1 {
            font-size: 20px
        }

        p.lead {
            color: var(--muted);
            font-size: 13px
        }

        /* ---- Cards (the boxes) ---- */
        .card {
            background: var(--card);
            border-radius: 14px;
            padding: 16px;
            box-shadow: 0 8px 30px rgba(40, 18, 60, 0.04);
            border: 1px solid var(--stroke);
            overflow: hidden;
        }

        .card+.card {
            margin-top: 0;
        }

        label {
            display: block;
            font-size: 12px;
            color: var(--muted);
            margin-bottom: 8px
        }

        .files {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap
        }

        input[type=file] {
            color: inherit
        }

        .small {
            font-size: 12px;
            color: var(--muted)
        }

        .history {
            margin-top: 12px;
            display: flex;
            flex-direction: column;
            gap: 8px
        }

        .hist-row {
            display: flex;
            gap: 8px;
            align-items: center
        }

        .chip {
            background: var(--chip);
            padding: 6px 10px;
            border-radius: 10px;
            font-weight: 600;
            border: 1px solid var(--stroke);
            color: var(--text)
        }

        .bad {
            color: #ef476f;
            background: rgba(239, 71, 111, 0.06);
            padding: 4px 8px;
            border-radius: 6px
        }

        .controls {
            display: flex;
            gap: 12px;
            margin-top: 10px;
            flex-wrap: wrap
        }

        button {
            background: transparent;
            border: 1px solid var(--stroke);
            color: var(--text);
            padding: 8px 12px;
            border-radius: 10px;
            cursor: pointer
        }

        button.primary {
            background: linear-gradient(90deg, var(--accent1), var(--accent2));
            color: #fff;
            border: 0;
            box-shadow: 0 6px 18px rgba(192, 88, 160, 0.10)
        }

        .main-col {
            display: flex;
            flex-direction: column;
            gap: 18px;
            min-width: 0;
        }

        .top-row {
            display: flex;
            gap: 12px;
            align-items: stretch
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px
        }

        th,
        td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px dashed rgba(40, 18, 60, 0.04);
            font-size: 14px
        }

        th {
            color: var(--muted);
            font-weight: 600
        }

        .muted {
            color: var(--muted);
            font-size: 13px
        }

        .small-right {
            font-size: 13px;
            color: var(--muted)
        }

        .candidate-list {
            max-height: 180px;
            overflow: auto;
            padding: 12px;
            border-radius: 10px;
            border: 1px dashed var(--stroke)
        }

        .spinner {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            border: 3px solid rgba(43, 37, 64, 0.12);
            border-top-color: var(--accent1);
            animation: spin 1s linear infinite;
            display: inline-block
        }

        @keyframes spin {
            to {
                transform: rotate(360deg)
            }
        }

        footer {
            grid-column: 1/-1;
            color: var(--muted);
            font-size: 13px;
            text-align: center;
            margin-top: 10px
        }

        .pill {
            background: linear-gradient(90deg, rgba(238, 225, 232, 0.14), rgba(134, 134, 134, 0.12));
            padding: 5px 5px;
            border-radius: 999px;
            font-weight: 600;
            border: 1px solid var(--stroke);
            color: var(--text)
        }

        .copy-btn {
            border: 1px solid var(--stroke);
            background: transparent;
            padding: 6px 8px;
            border-radius: 8px;
            cursor: pointer
        }

        .result-word {
            font-weight: 800;
            letter-spacing: 0.06em
        }

        .pattern-input {
            width: 132px;
            background-color: var(--card);
            color: var(--text);
            padding: 6px 10px;
            border-radius: 10px;
        }

        input[type=text],
        textarea {
            padding: 10px;
            border-radius: 10px;
            border: 1px solid var(--chip);
            color: var(--text);
            width: 100%;
            box-shadow: inset 0 1px 0 rgba(16, 12, 24, 0.02)
        }

        .flex {
            display: flex;
            gap: 8px;
            align-items: center
        }

        .hint {
            font-size: 12px;
            color: var(--muted)
        }

        hr {
            border: none;
            height: 1px;
            background: linear-gradient(90deg, rgba(192, 132, 252, 0.06), rgba(244, 114, 182, 0.04));
            margin: 14px 0;
        }

        /* responsive tweaks */
        @media (max-width:980px) {
            .wrap {
                grid-template-columns: 1fr;
                padding: 0
            }

            header {
                flex-direction: column;
                align-items: flex-start
            }

            .logo {
                width: 48px;
                height: 48px
            }

            .top-row {
                flex-direction: column
            }
        }
    </style>
</head>

<body>
    <div class="wrap">
        <header>
            <div class="logo-container" style="display: flex; align-items: center; gap: 10px;">
                <div class="logo">W</div>
                <img src="header.png" alt="Header img" style="height: 130px;">
            </div>
            <div>
                <h1>Wordle Next Guess</h1>
                <p class="lead">Upload or auto-load <span class="pill">answers.txt</span> & <span
                        class="pill">guesses.txt</span>. Enter guesses + feedback (g/y/b).</p>
            </div>

            <button id="themeToggle" class="theme-toggle" aria-label="Toggle dark mode" aria-pressed="false">🌙</button>

        </header>

        <!-- Left column: controls -->
        <aside class="card">
            <label>Load word lists (optional)
                <div class="files">
                    <input id="answersFile" type="file" accept=".txt">
                    <input id="guessesFile" type="file" accept=".txt">
                    <button id="tryAuto">Auto-load from repo</button>
                </div>
            </label>

            <hr>



            <label>Enter guess + feedback</label>
            <div class="flex">
                <input id="guessInput" class="pattern-input" type="text" maxlength="5" placeholder="guess (ex : ratel)"
                    style="text-transform:lowercase">
                <input id="patternInput" class="pattern-input" type="text" maxlength="5" placeholder="pattern (g/y/b)">
                <button id="addHistory" class="primary">Add</button>
            </div>
            <div class="hint">
                <li>Pattern: <b>g</b>=green, <b>y</b>=yellow, <b>b</b>=black.</li>
                <li>Example: <code>ratel → bbbyb</code></li>

            </div>

            <div class="history" id="historyList" style="margin-top:12px"></div>

            <div class="controls" style="margin-top:12px">
                <label style="display:flex;align-items:center;gap:8px"><input id="onlyAnswers" type="checkbox"> Use only
                    answers as guess candidates (faster)</label>
                <label style="display:flex;align-items:center;gap:8px"><input id="showAllCandidates" type="checkbox">
                    Show all candidate words</label>
            </div>

            <div style="display:flex;gap:8px;margin-top:12px">
                <button id="compute" class="primary">Compute suggestions</button>
                <button id="reset" title="Clear history">Reset</button>
            </div>

            <div style="margin-top:12px" id="loadStatus" class="muted">No word lists loaded yet.</div>
        </aside>

        <!-- Right column: results -->
        <main class="main-col">
            <div class="card">
                <div class="top-row">
                    <div style="flex:1; min-width:0">
                        <div class="small-right">Candidates (<span id="candidateCount">0</span>)</div>
                        <div class="candidate-list" id="candidatesBox">—</div>
                    </div>
                    <div style="width:320px; min-width:260px">
                        <div class="small-right">Top suggestions</div>
                        <div style="margin-top:8px" id="topBox">—</div>
                    </div>
                </div>

            </div>

            <div class="card" style="display:flex;flex-direction:column;gap:10px">
                <div class="muted">Notes</div>
                <ul class="muted" style="padding-left:18px">
                    <li>Prefer "Use only answers" if the browser is slow. Full guess list is stronger but heavier.</li>
                </ul>
            </div>

            <div class="card" style="display:flex;flex-direction:column;gap:10px">
                <div id="openersSection">
                    <div class="muted">Loading openers…</div>
                </div>
            </div>

        </main>
    </div>

    <script>
        /* ---------------------- Data & parsing ---------------------- */
        let answers = [];
        let guesses = [];

        const el = id => document.getElementById(id);
        const loadStatus = el('loadStatus');

        function parseWordList(text) {
            return text.split(/[\r\n]+/)
                .map(s => s.trim().toLowerCase())
                .filter(w => /^[a-z]{5}$/.test(w));
        }

        function relUrl(file) {
            // Resolve relative to current page URL so project pages work (no leading slash)
            return new URL(file, window.location.href).toString();
        }

        async function tryAutoLoad() {
            loadStatus.textContent = 'Trying to fetch answers.txt & guesses.txt (relative to this page)…';
            try {
                const [aResp, gResp] = await Promise.all([
                    fetch(relUrl('answers.txt')),
                    fetch(relUrl('guesses.txt'))
                ]);
                if (!aResp.ok || !gResp.ok) throw new Error('not found');
                const [aTxt, gTxt] = await Promise.all([aResp.text(), gResp.text()]);
                answers = parseWordList(aTxt);
                guesses = parseWordList(gTxt);
                onListsLoaded();
            } catch (e) {
                loadStatus.textContent = 'Auto-load failed : upload files or paste lists.';
            }
        }

        async function loadOpeners() {
            const container = document.getElementById('openersSection');

            // config: grid size
            const ROWS = 3;
            const COLS = 5;
            const TOTAL = ROWS * COLS;

            // try two possible filenames for robustness
            const candidateFiles = [
                relUrl('best_openers.txt')
            ];

            try {
                // fetch the first file that exists
                let bestResp = null;
                for (const url of candidateFiles) {
                    const r = await fetch(url);
                    if (r.ok) { bestResp = r; break; }
                }
                if (!bestResp) throw new Error("No best_openers file found");

                const bestTxt = await bestResp.text();

                const parseLines = txt => {
                    return txt.trim()
                        .split(/[\r\n]+/)
                        .map(line => {
                            const parts = line.trim().split(/\s+/);
                            // tolerate lines with only word or "word entropy"
                            const word = parts[0] ?? '';
                            const entropy = parts[1] ?? '';
                            return { word, entropy };
                        })
                        .filter(x => x.word); // drop empty lines
                };

                const entries = parseLines(bestTxt);

                // CSS (kept compact and similar to your previous style)
                const smallTableStyle = `
<style>
.openers-grid { border-collapse: collapse; margin-top:6px; font-size:12px; width:100%; }
.openers-grid td { padding:6px 8px; border:1px solid var(--chip); vertical-align:top; min-width:90px; }
.openers-cell-word { font-weight:600; display:block; }
.openers-cell-entropy { font-size:11px; color:var(--muted); display:block; margin-top:3px; }
.grid-wrap { display:block; overflow:auto; padding-top:6px;}
.header-row { font-weight:600; color:var(--muted); margin-bottom:6px; }
</style>`;

                // Build table row-major
                let tableHtml = `${smallTableStyle}
<div class="grid-wrap">
  <div class="muted">Best openers with entropy score (higher is better) - ${Math.min(entries.length, TOTAL)} shown</div>
  <table class="openers-grid" role="table" aria-label="Best openers">
    <tbody>`;

                for (let r = 0; r < ROWS; r++) {
                    tableHtml += '<tr>';
                    for (let c = 0; c < COLS; c++) {
                        const idx = r * COLS + c;
                        if (idx < entries.length) {
                            const e = entries[idx];
                            tableHtml += `<td>
                      <span class="openers-cell-word">${escapeHtml(e.word)}</span>
                      ${e.entropy ? `<span class="openers-cell-entropy">${escapeHtml(e.entropy)}</span>` : ''}
                    </td>`;
                        } else {
                            tableHtml += `<td></td>`;
                        }
                    }
                    tableHtml += '</tr>';
                }

                tableHtml += '</tbody></table></div>';

                container.innerHTML = tableHtml;
            } catch (e) {
                container.innerHTML = `<div class="bad">Failed to load openers: ${escapeHtml(e.message)}</div>`;
            }

            // small helper to escape user/file content for insertion into HTML
            function escapeHtml(s = '') {
                return String(s)
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&#39;');
            }
        }


        function onListsLoaded() {
            el('candidateCount').textContent = answers.length;
            loadStatus.textContent = `Loaded ${answers.length} answers and ${guesses.length} guesses.`;
            renderCandidatesPreview();
        }

        function renderCandidatesPreview(list = null) {
            const box = el('candidatesBox');
            const arr = list || answers;
            if (!arr || arr.length === 0) {
                box.textContent = '—';
                el('candidateCount').textContent = 0;
                return;
            }
            el('candidateCount').textContent = arr.length;
            const showAll = el('showAllCandidates').checked;
            const items = showAll ? arr : arr.slice(0, 80);
            box.innerHTML = items.map(w => `<span class="chip" style="margin:4px;display:inline-block">${w}</span>`).join('');
            if (!showAll && arr.length > 80) {
                box.insertAdjacentHTML('beforeend', `<div class="muted" style="margin-top:8px">Showing 80 of ${arr.length} candidates</div>`);
            }
        }

        /* ---------------------- Core solver ---------------------- */
        function feedback(guess, solution) {
            guess = guess.toLowerCase();
            solution = solution.toLowerCase();
            const res = ['b', 'b', 'b', 'b', 'b'];
            const solCount = {};
            for (const ch of solution) solCount[ch] = (solCount[ch] || 0) + 1;
            // greens
            for (let i = 0; i < 5; i++) {
                if (guess[i] === solution[i]) {
                    res[i] = 'g';
                    solCount[guess[i]] = (solCount[guess[i]] || 0) - 1;
                }
            }
            // yellows
            for (let i = 0; i < 5; i++) {
                if (res[i] === 'b' && (solCount[guess[i]] || 0) > 0) {
                    res[i] = 'y';
                    solCount[guess[i]] = solCount[guess[i]] - 1;
                }
            }
            return res.join('');
        }

        function consistentWithFeedback(word, guess, pattern) {
            return feedback(guess, word) === pattern;
        }

        function narrowCandidates(history) {
            let pool = answers.slice();
            for (const [guess, pat] of history) {
                pool = pool.filter(w => consistentWithFeedback(w, guess, pat));
            }
            return pool;
        }

        function expectedBucketSize(guess, pool) {
            const buckets = new Map();
            for (const sol of pool) {
                const pat = feedback(guess, sol);
                buckets.set(pat, (buckets.get(pat) || 0) + 1);
            }
            let sum = 0;
            for (const v of buckets.values()) sum += v * v;
            return sum / pool.length;
        }

        async function rankGuesses(pool, allGuesses, topk = 15, onlyAnswers = false, onProgress = null) {
            let searchSpace;
            if (onlyAnswers) {
                searchSpace = pool.slice();
            } else {
                const setPool = new Set(pool);
                searchSpace = pool.slice();
                for (const g of allGuesses) if (!setPool.has(g)) searchSpace.push(g);
            }

            const scored = [];
            const n = searchSpace.length;
            for (let i = 0; i < n; i++) {
                const g = searchSpace[i];
                if (!/^[a-z]{5}$/.test(g)) continue;
                const score = expectedBucketSize(g, pool);
                scored.push({ score, g });
                if (onProgress && (i % 50 === 0)) onProgress(i, n);
                if (i % 800 === 0) await new Promise(r => setTimeout(r, 0));
            }
            scored.sort((a, b) => a.score - b.score || a.g.localeCompare(b.g));
            return scored.slice(0, topk);
        }

        /* ---------------------- UI state ---------------------- */
        let history = [];

        function renderHistory() {
            const container = el('historyList');
            if (history.length === 0) {
                container.innerHTML = '<div class="muted">No guesses yet</div>';
                return;
            }
            container.innerHTML = '';
            history.forEach((hp, idx) => {
                const row = document.createElement('div');
                row.className = 'hist-row';
                row.innerHTML = `
      <div class="chip">${hp.guess}</div>
      <div class="chip">${hp.pattern}</div>
      <div style="flex:1" class="muted">pattern for ${hp.guess}</div>
      <button class="copy-btn" data-idx="${idx}">✂</button>
      <button class="copy-btn" data-del="${idx}">🗑</button>
    `;
                container.appendChild(row);
            });
            container.querySelectorAll('[data-idx]').forEach(btn => btn.onclick = e => {
                const idx = +e.currentTarget.dataset.idx;
                navigator.clipboard?.writeText(`${history[idx].guess} ${history[idx].pattern}`).then(() => {
                    e.currentTarget.textContent = '✓';
                    setTimeout(() => e.currentTarget.textContent = '✂', 700);
                });
            });
            container.querySelectorAll('[data-del]').forEach(btn => btn.onclick = e => {
                const idx = +e.currentTarget.dataset.del;
                history.splice(idx, 1);
                renderHistory();
            });
        }

        /* ---------------------- Events ---------------------- */

        el('tryAuto').addEventListener('click', tryAutoLoad);

        el('answersFile').addEventListener('change', async e => {
            const f = e.target.files[0];
            if (!f) return;
            const txt = await f.text();
            answers = parseWordList(txt);
            // if guesses empty, default to same list for guesses
            if (!guesses.length) guesses = answers.slice();
            onListsLoaded();
        });

        el('guessesFile').addEventListener('change', async e => {
            const f = e.target.files[0];
            if (!f) return;
            const txt = await f.text();
            guesses = parseWordList(txt);
            if (!answers.length) answers = guesses.slice();
            onListsLoaded();
        });




        el('addHistory').addEventListener('click', () => {
            const g = el('guessInput').value.trim().toLowerCase();
            const p = el('patternInput').value.trim().toLowerCase();
            if (!/^[a-z]{5}$/.test(g)) { alert('Guess must be 5 letters'); return; }
            if (!/^[gyb]{5}$/.test(p)) { alert('Pattern must be 5 chars of g/y/b'); return; }
            history.push({ guess: g, pattern: p });
            el('guessInput').value = ''; el('patternInput').value = '';
            renderHistory();
        });

        el('compute').addEventListener('click', async () => {
            if (!answers.length) { alert('No answers loaded — upload, paste, or add answers.txt to the repo and click Auto-load.'); return; }
            const onlyAnswers = el('onlyAnswers').checked;
            const hist = history.map(h => [h.guess, h.pattern]);
            let pool = narrowCandidates(hist);
            renderCandidatesPreview(pool);
            el('topBox').innerHTML = '<span class="spinner"></span> Computing…';
            const allGuesses = (guesses.length ? guesses : answers);
            const scored = await rankGuesses(pool, allGuesses, 40, onlyAnswers, (i, n) => {
                el('topBox').innerHTML = `<span class="spinner"></span> processing ${i}/${n}`;
            });
            const resultsArea = el('resultsArea');
            if (!scored.length) {
                resultsArea.innerHTML = '<div class="muted">No suggested guesses (empty search space).</div>';
                el('topBox').textContent = '—';
                return;
            }
            el('topBox').innerHTML = scored.slice(0, 6).map(s => `<div style="display:flex;justify-content:space-between;align-items:center;padding:6px 0">
    <div><span class="result-word">${s.g}</span> <span class="muted">~${s.score.toFixed(2)}</span></div>
    <div><button class="copy-btn" data-copy="${s.g}">copy</button></div>
  </div>`).join('');
            el('topBox').querySelectorAll('[data-copy]').forEach(b => b.onclick = e => { navigator.clipboard?.writeText(e.currentTarget.dataset.copy); e.currentTarget.textContent = '✓'; setTimeout(() => e.currentTarget.textContent = 'copy', 600); });

            resultsArea.innerHTML = `<table>
    <thead><tr><th>Rank</th><th>Guess</th><th>Expected remaining</th><th>Action</th></tr></thead>
    <tbody>${scored.map((s, idx) => `<tr><td>${idx + 1}</td><td class="result-word">${s.g}</td><td>${s.score.toFixed(2)}</td><td><button class="copy-btn" data-copy="${s.g}">copy</button></td></tr>`).join('')}</tbody>
  </table>`;
            resultsArea.querySelectorAll('[data-copy]').forEach(b => b.onclick = e => { navigator.clipboard?.writeText(e.currentTarget.dataset.copy); e.currentTarget.textContent = '✓'; setTimeout(() => e.currentTarget.textContent = 'copy', 600); });
        });

        el('reset').addEventListener('click', () => {
            history = [];
            renderHistory();
            el('resultsArea').innerHTML = '';
            el('topBox').textContent = '—';
            renderCandidatesPreview(answers);
        });

        /* Auto-load on page open if files exist */
        window.addEventListener('load', () => {
            tryAutoLoad();
            renderHistory();
            loadOpeners();
        });

        document.addEventListener("DOMContentLoaded", () => {
            const themes = [
                { bg: "#f6fff8", card: "#ffffff", muted: "#5f6f61", accent1: "#34d399", accent2: "#10b981", stroke: "rgba(16,38,30,0.06)", text: "#1b3324", chip: "#e6fdf3" },
                { bg: "#fff8fb", card: "#ffffff", muted: "#7b6f88", accent1: "#f472b6", accent2: "#c084fc", stroke: "rgba(30,16,38,0.06)", text: "#2b2540", chip: "#fff0f7" }
            ];

            const lightTheme = themes[1]; // Purple

            // Dark theme
            const darkTheme = {
                bg: "#1e1e1e",
                card: "#252526",
                muted: "#858585",
                accent1: "#c586c0",
                accent2: "#569cd6",
                stroke: "#3c3c3c",
                text: "#d4d4d4",
                chip: "#2d2d2d"
            };

            const root = document.documentElement;
            const btn = document.getElementById('themeToggle');

            function applyTheme(themeObj) {
                Object.entries(themeObj).forEach(([key, value]) => {
                    root.style.setProperty(`--${key}`, value);
                });
            }

            function updateButton(mode) {
                if (mode === 'dark') {
                    btn.textContent = '☀️'; // clicking will go to light
                    btn.setAttribute('aria-pressed', 'true');
                    btn.setAttribute('aria-label', 'Switch to light mode');
                } else {
                    btn.textContent = '🌙'; // clicking will go to dark
                    btn.setAttribute('aria-pressed', 'false');
                    btn.setAttribute('aria-label', 'Switch to dark mode');
                }
            }

            // Determine initial mode: localStorage -> prefers-color-scheme -> default 'light'
            let saved = localStorage.getItem('color-mode');
            let initialMode;
            if (saved === 'dark' || saved === 'light') initialMode = saved;
            else if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) initialMode = 'dark';
            else initialMode = 'light';

            // Apply initial theme
            applyTheme(initialMode === 'dark' ? darkTheme : lightTheme);
            updateButton(initialMode);

            // Toggle handler
            btn.addEventListener('click', () => {
                const next = btn.getAttribute('aria-pressed') === 'true' ? 'light' : 'dark';
                applyTheme(next === 'dark' ? darkTheme : lightTheme);
                updateButton(next);
                localStorage.setItem('color-mode', next);
            });
        });
    </script>
</body>

</html>